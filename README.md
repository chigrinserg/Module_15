Представленная программа демонстрирует хранение введенных пользо-вателями паролей в хеш-таблице и сохранение данных этой таблицы в текстовых файлах. Программа представляет собой часть более обширного программ-ного комплекса (чата или любого другого объекта), в котором требуется реги-страция пользователей, хранение логинов и паролей, а также списка пользователей.

СТРУКТУРА ПРОГРАММЫ
Хеш-таблица вместе с хеш-функцией реализованы в классе «Users». Хеш-функция реализована методом квадратичного пробирования и далее включается в функцию add(), принимающую в качестве аргументов вводимый пароль и личный номер. Класс Users включает заголовочный файл «Users.h» и блок реализации функций «Users.cpp». Внутри заголовка Users.h определены структура HashPerson и внутренний массив HashPerson* array , отвечающие за формирование  хеш-таблицы с парами «ключ – значение». При этом ключом является введенный пользователем пароль, а значением – его личный номер, который автоматически генерируется функцией-счетчиком int countNumber(), определенной и реализованной в классе «Numbers». Функция запоминает номер, сгенерированный при последнем вызове, в текстовом файле Numbers.txt. Личный номер был выбран в качестве значения для связи со списком пользова-телей, реализованным в классе Person (Person.h и Person.cpp). Список пользо-вателей включает в себя следующие данные: личный номер, логин, фамилию, имя, отчество и телефон. 

ВВОД ЛОГИНА И ПАРОЛЯ
Связь между логином и паролем осуществляется через личный номер пользователя (вводится в список также автоматически) в блоке main. Вызван-ная поисковая функция  int find() класса Users, принимающая вводимый пароль, возвращает значение личного номера из хеш-таблицы и инициализирует им переменную int Num. Затем функция поиска номера в списке пользователей int getID() класса Person принимает введенный логин и также возвращает значение личного номера из массива списка пользователей, инициализируя  переменную int Num_pers. Если логин и пароль введены правильно, переменные оказываются равными. При этом условии доступ к программе открывается, в противном случае пользователю будет предложено пройти регистрацию. 

РЕГИСТРАЦИЯ ПОЛЬЗОВАТЕЛЕЙ
Регистрация пользователя осуществляется в блоке main. Вначале вызывается функция countNumber(), инициализирующая переменную int ID. Эта пе-ременная передается в качестве аргумента в функцию add() и в функцию fillArray(), определенную в классе Person и заполняющую значениями массив списка пользователей std::vector<Person> _array (далее сохраняется в текстовый файл listOfUsers.txt). А поскольку при каждом вызове функция countNumber() генерирует уникальные номера, то каждый пользователь получает свой персональный личный номер, одновременно вводимый и в хеш-таблицу функцией add(), в качестве второго аргумента принимающей вводимый пользователем пароль. На основе пароля вычисляется хеш и пара «пароль – ID» вводится в хеш-таблицу со своим индексом. 

СОХРАНЕНИЕ ХЕШ-ТАБЛИЦЫ
Данные хеш-таблицы сохраняются в текстовых файлах, причем пароли сохраняются функцией deep_pass() в файл pass.txt, а личные номера функция deep_id() сохраняет в файл id.txt. Почему в два файла, а не в один? Это связано с тем, что, будучи сохраненными в один общий файл, пароль и номер пре-образуются в строку. Для того, чтобы поместить их обратно в хеш-таблицу при новом запуске программы, нужно провести пароль через хеш-функцию, находящуюся внутри функции add(). Но эта функция принимает ДВА аргумента, прием один – строковый, а другой – целочисленный. Посему и приходится из-влекать их по отдельности. Функция getpasstext(int n) извлекает пароли из тек-стового файла, загружает их в массив std::vector<std::string> arr_pass и возвра-щает пароль, а функция getIDtext(int n) загружает номера в массив std::vector<int> arr_id, предварительно преобразуя их из строковых значений в целочисленные и возвращает личный номер. Далее обе эти функции переда-ются как аргументы в функцию add(). 
Для чего понадобился аргумент n в этих функциях? Он принимает значения индексов массивов, по которым извлекаются пароль и номер. Строки в текстовых  файлах индексов, как таковых, не имеют, поэтому и приходится в каче-стве промежуточного этапа загружать их в массивы (хотя это и поедает очень много времени). А далее аргумент n  принимает значения итератора внешнего цикла, в который помещается вызов функции add() в блоке main. Так происхо-дит передача в функцию add() всех значений, сохраненных в файлах. Конечно, за такое удовольствие приходится расплачиваться квадратичной временной сложностью загрузки хеш-таблицы. Если 100 записей грузятся за 0,29 секунды, то 1000 записей – уже за 13,8 секунд. Это неприемлемо для  больших проектов, но для небольших локальных задач (с малым числом пользователей) может быть, где-то и подойдет (можно не создавать базу данных или подключаться к уже существующей). 

УДАЛЕНИЕ ПОЛЬЗОВАТЕЛЕЙ
Происходит следующим образом. В блоке main вызывается функция del(), определенная в классе Users. Эта функция принимает пароль удаляемого пользователя, помечает статус пары «пароль – значение» как «удаленный», после чего возвращает номер, соответствующий паролю. Этим номером иници-ализируется переменная int del_p, которая затем передается в качестве аргумента в функцию deletePerson(del_p), определенную в классе Person. Если значение ID, извлеченное из массива std::vector<Person> _array, совпадет со значением переменной, то весь элемент массива перезаписывается прочерками (или любыми другими на усмотрение разработчика). Классическое удаление элемента не получается - функция erase() хорошо работает с целочисленными векторами, а вот с вектором элементов класса все время происходит выход за границы массива. Поэтому пришлось ограничиться перезаписью без реального удаления. 
Что же касается элементов хеш-таблицы, помеченных как удаленные, то они в текстовые файлы не сохраняются и в при повторной загрузке в таблицу не попадают. 

P. S. Для тестирования прилагается документ Word с введенными в про-грамму номерами, логинами, паролями и пользователями
